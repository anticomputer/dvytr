#!/usr/bin/env bash

set -e

VERSION="1.0.0"
IMAGE_NAME="dvytr"
CONTAINER_PREFIX="dvytr"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Get the directory where this script is located (follows symlinks)
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$SCRIPT_DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"

# Default configuration
CONFIG_FILE=".dvytr.conf"
CONTAINER_NAME=""
WORKSPACE_PATH="$(pwd)"
DOCKER_PORT_MAPPINGS=()  # Format: "host_port:container_port"
ENV_VARS=()
ADDITIONAL_VOLUMES=()
SOCAT_FORWARDS=()  # Format: "container_listen_port:target_host:target_port"
PATH_DIRS=()  # Directories relative to /workspace to add to PATH
INIT_SCRIPT=""  # Path to initialization script (relative to workspace)
RUN_INIT=""  # Embedded initialization script content

# Load configuration from file if it exists
load_config() {
    local config_path="${WORKSPACE_PATH}/${CONFIG_FILE}"
    if [[ -f "$config_path" ]]; then
        print_info "Loading configuration from ${CONFIG_FILE}"
        # Source the config file
        # shellcheck disable=SC1090
        source "$config_path"
    fi
}

# Parse .env file and add variables to ENV_VARS array
load_env_file() {
    local env_file="${WORKSPACE_PATH}/.env"
    if [[ -f "$env_file" ]]; then
        print_info "Loading environment variables from .env"
        local line_count=0
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

            # Remove leading/trailing whitespace
            line=$(echo "$line" | sed -e 's/^[[:space:]]//' -e 's/[[:space:]]$//')

            # Check if line contains an assignment
            if [[ "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
                ENV_VARS+=("$line")
                line_count=$((line_count + 1))
            fi
        done < "$env_file"

        if [[ $line_count -gt 0 ]]; then
            print_info "Loaded $line_count environment variable(s) from .env"
        fi
    fi
}

# Resolve passage password manager secrets
# Processes ENV_VARS array and replaces "passage:path" with actual secrets
resolve_passage_secrets() {
    # First check if any passage: references exist
    local has_passage_refs=false
    for env in "${ENV_VARS[@]}"; do
        if [[ "$env" =~ passage: ]]; then
            has_passage_refs=true
            break
        fi
    done

    # If no passage references, skip this function
    if [[ "$has_passage_refs" == false ]]; then
        return 0
    fi

    # Check if passage is available
    if ! command -v passage >/dev/null 2>&1; then
        print_error "passage command not found but passage: reference detected in configuration"
        print_info "Install passage from: https://github.com/FiloSottile/passage"
        exit 1
    fi

    # Process each ENV_VAR for passage: references
    local resolved_vars=()
    for env in "${ENV_VARS[@]}"; do
        # Match pattern: VAR_NAME=passage:path/to/secret
        if [[ "$env" =~ ^([^=]+)=passage:(.+)$ ]]; then
            local var_name="${BASH_REMATCH[1]}"
            local passage_path="${BASH_REMATCH[2]}"

            print_info "Retrieving secret from passage: $passage_path"

            # Retrieve secret (stderr goes to terminal for password prompts)
            local secret
            local passage_output
            if ! passage_output=$(passage show "$passage_path" 2>&1); then
                print_error "Failed to retrieve passage secret: $passage_path"
                echo "$passage_output" >&2
                exit 1
            fi

            # Handle multi-line secrets (use first line only, standard password-store convention)
            secret=$(echo "$passage_output" | head -n1)

            if [[ -z "$secret" ]]; then
                print_warning "Empty secret retrieved from passage: $passage_path"
            fi

            # Add resolved variable (secret is not echoed for security)
            resolved_vars+=("${var_name}=${secret}")
        else
            # Not a passage reference, keep as-is
            resolved_vars+=("$env")
        fi
    done

    # Replace ENV_VARS with resolved values
    ENV_VARS=("${resolved_vars[@]}")
}

# Resolve pass (password-store) secrets
# Processes ENV_VARS array and replaces "pass:path" with actual secrets
resolve_pass_secrets() {
    # First check if any pass: references exist
    local has_pass_refs=false
    for env in "${ENV_VARS[@]}"; do
        if [[ "$env" =~ pass: ]]; then
            has_pass_refs=true
            break
        fi
    done

    # If no pass references, skip this function
    if [[ "$has_pass_refs" == false ]]; then
        return 0
    fi

    # Check if pass is available
    if ! command -v pass >/dev/null 2>&1; then
        print_error "pass command not found but pass: reference detected in configuration"
        print_info "Install pass from: https://www.passwordstore.org/"
        exit 1
    fi

    # Process each ENV_VAR for pass: references
    local resolved_vars=()
    for env in "${ENV_VARS[@]}"; do
        # Match pattern: VAR_NAME=pass:path/to/secret
        if [[ "$env" =~ ^([^=]+)=pass:(.+)$ ]]; then
            local var_name="${BASH_REMATCH[1]}"
            local pass_path="${BASH_REMATCH[2]}"

            print_info "Retrieving secret from pass: $pass_path"

            # Retrieve secret (stderr goes to terminal for password prompts)
            local secret
            local pass_output
            if ! pass_output=$(pass show "$pass_path" 2>&1); then
                print_error "Failed to retrieve pass secret: $pass_path"
                echo "$pass_output" >&2
                exit 1
            fi

            # Handle multi-line secrets (use first line only, standard password-store convention)
            secret=$(echo "$pass_output" | head -n1)

            if [[ -z "$secret" ]]; then
                print_warning "Empty secret retrieved from pass: $pass_path"
            fi

            # Add resolved variable (secret is not echoed for security)
            resolved_vars+=("${var_name}=${secret}")
        else
            # Not a pass reference, keep as-is
            resolved_vars+=("$env")
        fi
    done

    # Replace ENV_VARS with resolved values
    ENV_VARS=("${resolved_vars[@]}")
}

# Generate container name based on current directory
generate_container_name() {
    local dir_name
    local path_hash

    # Get directory name (sanitized)
    dir_name=$(basename "$WORKSPACE_PATH" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]-')

    # Generate hash of full path (first 8 chars) for uniqueness
    # This ensures different paths with same basename don't collide
    if command -v md5sum >/dev/null 2>&1; then
        path_hash=$(echo -n "$WORKSPACE_PATH" | md5sum | cut -c1-8)
    elif command -v md5 >/dev/null 2>&1; then
        # macOS uses 'md5' instead of 'md5sum'
        path_hash=$(echo -n "$WORKSPACE_PATH" | md5 | cut -c1-8)
    else
        # Fallback: use simple hash if md5 not available
        path_hash=$(printf '%s' "$WORKSPACE_PATH" | cksum | cut -d' ' -f1)
    fi

    echo "${CONTAINER_PREFIX}-${dir_name}-${path_hash}"
}

# Build the Docker image
build_image() {
    print_info "Building Docker image '${IMAGE_NAME}'..."

    if [[ ! -f "${SCRIPT_DIR}/Dockerfile" ]]; then
        print_error "Dockerfile not found at ${SCRIPT_DIR}/Dockerfile"
        exit 1
    fi

    docker build -t "${IMAGE_NAME}:latest" "${SCRIPT_DIR}"
    print_success "Docker image '${IMAGE_NAME}' built successfully"
}

# Check if image exists
image_exists() {
    docker image inspect "${IMAGE_NAME}:latest" >/dev/null 2>&1
}

# Check if container exists
container_exists() {
    docker container inspect "$1" >/dev/null 2>&1
}

# Check if container is running
container_running() {
    [[ "$(docker container inspect -f '{{.State.Running}}' "$1" 2>/dev/null)" == "true" ]]
}

# Start a new development container
cmd_run() {
    load_config
    load_env_file
    resolve_passage_secrets
    resolve_pass_secrets

    # Use custom name if provided, otherwise generate from directory
    CONTAINER_NAME="${CONTAINER_NAME:-$(generate_container_name)}"

    # Check if image exists, build if not
    if ! image_exists; then
        print_warning "Image '${IMAGE_NAME}' not found, building..."
        build_image
    fi

    # Check if container already exists
    if container_exists "$CONTAINER_NAME"; then
        if container_running "$CONTAINER_NAME"; then
            print_warning "Container '${CONTAINER_NAME}' is already running"
            print_info "Use 'dvytr shell' to attach to it"
            exit 0
        else
            print_info "Starting existing container '${CONTAINER_NAME}'..."
            docker start "$CONTAINER_NAME"
            print_success "Container '${CONTAINER_NAME}' started"
            print_info "Use 'dvytr shell' to attach to it"
            exit 0
        fi
    fi

    # Build docker run command
    local docker_args=(
        "run"
        "-it"
        "-d"
        "--name" "$CONTAINER_NAME"
        "-v" "${WORKSPACE_PATH}:/workspace"
        "-w" "/workspace"
    )

    # Add port mappings
    for port in "${DOCKER_PORT_MAPPINGS[@]}"; do
        docker_args+=("-p" "$port")
    done

    # Add environment variables
    for env in "${ENV_VARS[@]}"; do
        docker_args+=("-e" "$env")
    done

    # Add socat port forwards as environment variables
    local i=0
    for forward in "${SOCAT_FORWARDS[@]}"; do
        docker_args+=("-e" "SOCAT_FORWARD_$i=$forward")
        i=$((i + 1))
    done

    # Add PATH directories as environment variables
    local j=0
    for path_dir in "${PATH_DIRS[@]}"; do
        docker_args+=("-e" "PATH_DIR_$j=$path_dir")
        j=$((j + 1))
    done

    # Add init script path if configured
    if [[ -n "$INIT_SCRIPT" ]]; then
        docker_args+=("-e" "DVYTR_INIT_SCRIPT=$INIT_SCRIPT")
    fi

    # Add embedded init script content if configured (takes precedence over INIT_SCRIPT)
    if [[ -n "$RUN_INIT" ]]; then
        docker_args+=("-e" "DVYTR_RUN_INIT=$RUN_INIT")
    fi

    # Add additional volumes
    for volume in "${ADDITIONAL_VOLUMES[@]}"; do
        docker_args+=("-v" "$volume")
    done

    docker_args+=("${IMAGE_NAME}:latest")

    print_info "Starting container '${CONTAINER_NAME}'..."
    docker "${docker_args[@]}"

    print_success "Container '${CONTAINER_NAME}' started successfully"
    print_info "Workspace: ${WORKSPACE_PATH} -> /workspace"
    print_info "Use 'dvytr shell' to attach to the container"
}

# Attach to running container
cmd_shell() {
    load_config
    CONTAINER_NAME="${CONTAINER_NAME:-$(generate_container_name)}"

    if ! container_exists "$CONTAINER_NAME"; then
        print_error "Container '${CONTAINER_NAME}' does not exist"
        print_info "Use 'dvytr run' to create it"
        exit 1
    fi

    if ! container_running "$CONTAINER_NAME"; then
        print_info "Container '${CONTAINER_NAME}' is not running, starting..."
        docker start "$CONTAINER_NAME"
    fi

    print_info "Attaching to container '${CONTAINER_NAME}'..."
    docker exec -it --user dev "$CONTAINER_NAME" /bin/bash --login
}

# Execute command in container
cmd_exec() {
    load_config
    CONTAINER_NAME="${CONTAINER_NAME:-$(generate_container_name)}"

    if [[ $# -eq 0 ]]; then
        print_error "No command provided"
        print_info "Usage: dvytr exec <command> [args...]"
        exit 1
    fi

    if ! container_exists "$CONTAINER_NAME"; then
        print_error "Container '${CONTAINER_NAME}' does not exist"
        print_info "Use 'dvytr run' to create it"
        exit 1
    fi

    if ! container_running "$CONTAINER_NAME"; then
        print_info "Container '${CONTAINER_NAME}' is not running, starting..."
        docker start "$CONTAINER_NAME"
    fi

    # Use -it flags only if stdin is a TTY
    local tty_flags=""
    if [[ -t 0 ]]; then
        tty_flags="-it"
    fi

    docker exec $tty_flags --user dev "$CONTAINER_NAME" bash --login -c "$*"
}

# Stop the container
cmd_stop() {
    load_config
    CONTAINER_NAME="${CONTAINER_NAME:-$(generate_container_name)}"

    if ! container_exists "$CONTAINER_NAME"; then
        print_warning "Container '${CONTAINER_NAME}' does not exist"
        exit 0
    fi

    if ! container_running "$CONTAINER_NAME"; then
        print_warning "Container '${CONTAINER_NAME}' is already stopped"
        exit 0
    fi

    print_info "Stopping container '${CONTAINER_NAME}'..."
    docker stop "$CONTAINER_NAME"
    print_success "Container '${CONTAINER_NAME}' stopped"
}

# Clean up container and optionally image
cmd_clean() {
    load_config
    CONTAINER_NAME="${CONTAINER_NAME:-$(generate_container_name)}"

    local remove_image=false
    if [[ "$1" == "--image" ]] || [[ "$1" == "-i" ]]; then
        remove_image=true
    fi

    # Remove container if it exists
    if container_exists "$CONTAINER_NAME"; then
        print_info "Removing container '${CONTAINER_NAME}'..."
        docker rm -f "$CONTAINER_NAME" >/dev/null 2>&1
        print_success "Container '${CONTAINER_NAME}' removed"
    else
        print_warning "Container '${CONTAINER_NAME}' does not exist"
    fi

    # Remove image if requested
    if [[ "$remove_image" == true ]]; then
        if image_exists; then
            print_info "Removing image '${IMAGE_NAME}'..."
            docker rmi "${IMAGE_NAME}:latest"
            print_success "Image '${IMAGE_NAME}' removed"
        else
            print_warning "Image '${IMAGE_NAME}' does not exist"
        fi
    fi
}

# List running dvytr containers
cmd_list() {
    print_info "DevYeeter containers:"
    docker ps -a --filter "name=${CONTAINER_PREFIX}-" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
}

# Show status of current container
cmd_status() {
    load_config
    CONTAINER_NAME="${CONTAINER_NAME:-$(generate_container_name)}"

    if ! container_exists "$CONTAINER_NAME"; then
        print_warning "Container '${CONTAINER_NAME}' does not exist"
        exit 0
    fi

    print_info "Container: ${CONTAINER_NAME}"
    docker inspect "$CONTAINER_NAME" --format='Status: {{.State.Status}}
Created: {{.Created}}
Image: {{.Config.Image}}
Workspace: {{range .Mounts}}{{if eq .Destination "/workspace"}}{{.Source}}{{end}}{{end}}'
}

# Show help
cmd_help() {
    cat <<EOF
DevYeeter (dvytr) v${VERSION} - Multi-language Development Container Tool

USAGE:
    dvytr <command> [options]

COMMANDS:
    run             Start a new development container with current directory mounted
    shell           Attach to the running container (opens bash shell)
    exec <cmd>      Execute a command in the running container
    stop            Stop the running container
    clean [-i]      Remove the container (use -i to also remove the image)
    list            List all dvytr containers
    status          Show status of current container
    build           Build/rebuild the Docker image
    version         Show version information
    help            Show this help message

CONFIGURATION:
    Create a .dvytr.conf file in your project directory to customize:

    # Custom container name
    CONTAINER_NAME="my-custom-name"

    # Port mappings (host:container)
    PORTS=("8080:8080" "3000:3000")

    # Environment variables
    ENV_VARS=("NODE_ENV=development" "DEBUG=true")

    # Additional volume mounts
    ADDITIONAL_VOLUMES=("/host/path:/container/path")

ENVIRONMENT VARIABLES:
    Create a .env file in your project directory to automatically load
    environment variables into the container:

    DATABASE_URL=postgresql://localhost:5432/mydb
    API_KEY=your-secret-key
    NODE_ENV=development

    The .env file is automatically loaded when running 'dvytr run'

PASSWORD MANAGERS:
    DevYeeter supports retrieving secrets from password managers.
    Use 'passage:' or 'pass:' prefix in environment variables:

    In .dvytr.conf:
    ENV_VARS=("API_KEY=passage:services/api/key")
    ENV_VARS=("API_KEY=pass:services/api/key")

    In .env file:
    API_KEY=passage:services/api/key          # Using passage (age encryption)
    DATABASE_PASSWORD=pass:databases/postgres # Using pass (GPG encryption)

    Secrets are retrieved when running 'dvytr run' before container creation.

    Install passage: https://github.com/FiloSottile/passage
    Install pass: https://www.passwordstore.org/

EXAMPLES:
    # Start a development container
    dvytr run

    # Attach to the container
    dvytr shell

    # Run a command in the container
    dvytr exec npm install

    # Stop the container
    dvytr stop

    # Remove container and image
    dvytr clean --image

INSTALLED TOOLS:
    - C/C++ (gcc, g++, clang, gdb, valgrind)
    - Python 3 (pip, venv)
    - Node.js v20 (npm)
    - pnpm (main package manager)
    - TypeScript (tsc, ts-node)
    - Go $(grep 'GO_VERSION=' "${SCRIPT_DIR}/Dockerfile" | cut -d'=' -f2 || echo "")
    - Rust (cargo, rustc)
    - Editors: vim, emacs, nano
    - Tools: git, curl, wget, jq, tree, htop

EOF
}

# Show version
cmd_version() {
    echo "DevYeeter (dvytr) v${VERSION}"
}

# Main command dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        cmd_help
        exit 0
    fi

    local command=$1
    shift

    case "$command" in
        run)
            cmd_run "$@"
            ;;
        shell)
            cmd_shell "$@"
            ;;
        exec)
            cmd_exec "$@"
            ;;
        stop)
            cmd_stop "$@"
            ;;
        clean)
            cmd_clean "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        build)
            build_image "$@"
            ;;
        version|--version|-v)
            cmd_version
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            print_error "Unknown command: $command"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
